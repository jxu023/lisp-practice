
(defun play ()
  (let ((board (make-array '(3 3) :initial-element '_))
	(turn 'X)
	(row 0)
	(col 0))
    (print-arr board)
    (loop while (not (terminalp board row col)) do
      (progn (setf row (read))
	     (setf col (read))
	     (when (move row col board turn)
	       (setf turn (flip turn)))
	     (print-arr board)))
    (format t "game over~%")))

(defun flip (elem)
  (cadr (assoc elem '((X O) (O X) (_ _)))))

(defun in-bounds (row col)
  (and (>= row 0)
       (>= col 0)
       (< row 3)
       (< col 3)))

(defun move (row col board turn)
  (let ((color (aref board row col)))
    (if (and (in-bounds row col)
	     (equal color '_))
	(progn (setf (aref board row col) turn) t)
	(format t "invalid move, retry~%"))))

(defun print-arr (arr)
  (let ((last-dim (length (array-dimensions arr))))
    (labels ((arr-helper (coords cur-dim)
	       (if (equal cur-dim last-dim)
		   (format t "~A " (apply #'aref (cons arr (reverse coords))))
		   (progn
		     (dotimes (dim-val (array-dimension arr cur-dim))
		       (arr-helper (cons dim-val coords) (+ 1 cur-dim)))
		     (dotimes (x (- last-dim cur-dim))
		       (format t "~%"))))))
      (arr-helper nil 0))))

(defun terminalp (board row col)
  (let ((color (aref board row col)))
    (loop for (r c) in '((0 1) (1 1) (1 0)) do
      (let ((length 1))
	(loop for coeff in '(1 -1) do
	  (let ((nr (+ row (* coeff r)))
		(nc (+ col (* coeff c))))
	    (when (and (in-bounds nr nc)
		       (equal (aref board nr nc) color))
	      (incf length))))
	(when (= length 3)
	  (return t)))))
  nil)
